---
layout: post
title: "1810D Climbing The Tree"
---
The problem can be found [here](https://codeforces.com/problemset/problem/1810/D)

### My Thought Process 
If we have event type 1, given $a$ and $b$, each day the distance will increased by $a-b$. That means that on the $n$th day, the snail's distance will be at $(n-1)(a-b)$. Then that means that if it took him till the $n$th day to reach top, it could also mean that he reached the top when he climbed the $a$ meters. So the height could be possibly between 
$$[(n-1)(a-b), (n-1)(a-b) + a]$$

But, on the highest point of the $n-1$th day, he would have been at a higher point than $(n-1)(a-b)$ because the snail would've been at $(n-2)(a-b) + a = (n-1)(a-b) + b$ so we should readjust the height to

$$[(n-2)(a-b) + a + 1, (n-1)(a-b) + a]$$

We add the +1 because if not, he would've stopped at the $n-1$th day. 

Updating the interval is easy, we just keep track if the new interval intersect the old interval and then take the max $l$ and min $r$ to shortern it.

For the second query, we need to check two cases. If the real height is $l$ or the real height is $r$ and would the number of days differ. We only consider these two because they have the greatest difference in their height. 

We then just check the number of days it would've take if $l$ is the height and if $r$ is the real height and if they are the same or not. If they are the same, we can determine it, and if they are not, we cannot determine it.
### Implementation  
The implementation is probably a bit messy. Some things to note: 

1. We check if both nl and nr is left than 0 in the second query because they mean it will take one day in both cases and it will break if we don't add it.
2. We check if $n-1$ is in the first query because $n-2$ results in that being negative in that case.

{% highlight cpp %}
#include <bits/stdc++.h>

using ll = long long;
#define pb push_back

using namespace std;

const int MOD = 1e9+7;
const int MAXN = 2e6+1;
const int INF = 2e9;    
const long long IINF = 2e18;

#define int long long
void solve() { 
    int q; cin >> q;
    int l = -1;
    int r = -1;

    while(q--){
        int type; cin >> type;
        int a, b; cin >> a >> b;
        if(type == 1){
            int n; cin >> n;
            int nl = 0, nr = 0;
            if(n == 1){
                nl = 0;
                nr = (a-b) * (n-1) + a;
            }
            else{
                nl = (a-b) * (n-2) + a + 1;
                nr = (a-b) * (n-1) + a;
            }
            if(l == -1){
                l = nl; r = nr; 
                cout << 1 << ' ';
                continue;
            }

            if(nr < l || nl > r){
                cout << 0 << ' '; continue;
            }

            cout << 1 << ' ';

            l = max(l, nl);
            r = min(r, nr);
        }
        else{
            if(l == -1){cout << -1 << ' '; continue;}
            int nl = l - a;
            int nr = r - a;
            if(nl <= 0 && nr <= 0){cout << 1 << ' '; continue;}

            if(nl / (a-b) + (nl % (a-b) > 0) != nr / (a-b) + (nr % (a-b) > 0)){
                cout << -1 << ' ';
            }
            else{
                cout << nl / (a-b) + (nl % (a-b) > 0) + 1 << ' ';
            }
        }
    }

    cout << endl;
}

int32_t main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while(t--){
        solve();
    }

    return 0;
}

{% endhighlight %}


See [here](https://codeforces.com/blog/entry/114521) for the solution and another implementation. 

