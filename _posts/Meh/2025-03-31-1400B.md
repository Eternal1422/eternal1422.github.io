---
layout: post
title: "1400B RPG Protagonist"
---
The problem can be found [here](https://codeforces.com/problemset/problem/1400/B)

### My Thought Process 
This is a problem of implementation. Let's just always assume that swords or cheaper than axes, if not we can just swap everything.

We can just loop through how many swords taken for one person, take the maximum amount of axes with the space left. Then, the other person can take as many swords he can and as many axes if enough space.

This should be clear as it will be optimal choosing the cheaper item first then the more expensive.

### Implementation  
The implementation is actually not that bad.

{% highlight cpp %}
#include <bits/stdc++.h>

using ll = long long;
#define pb push_back

using namespace std;

const int MOD = 1e9+7;
const int MAXN = 2e6+1;
const int INF = 2e9;    
const long long IINF = 2e18;

void solve() { 
    int p, f; cin >> p >> f;
    int cs, cw; cin >> cs >> cw;
    int s, w; cin >> s >> w;

    int ans = 0;

    if(w < s){
        swap(w, s);
        swap(cs, cw);
    }

    for(int i = 0; i <= min(cs, p / s); ++i){
        int swords = cs; // current swords left
        int axes = cw; // current axes left

        int swordsp = i;
        int axesp = min(axes, (p - swordsp * s)/w);

        swords -= swordsp;
        axes -= axesp;

        int swordsf = min(swords, f/s);
        int axesf = min(axes, (f - swordsf * s)/w);

        ans = max(ans, swordsp + axesp + swordsf + axesf);
    }

    cout << ans << endl;
}

int32_t main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    // freopen("test.in", "r", stdin);
    // freopen("test.out", "w", stdout);
    int t;
    cin >> t;
    while(t--){
        solve();
    }

    return 0;
}
{% endhighlight %}


See [here](https://codeforces.com/blog/entry/81916) for the solution and another implementation. 

