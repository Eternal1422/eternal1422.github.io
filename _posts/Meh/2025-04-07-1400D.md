---
layout: post
title: "1400d"
---
The problem can be found [here](https://codeforces.com/problemset/problem/1400/D)

### My Thought Process 
Well, since $n$ is relatively small, we can have a solution run in $O(n^2)$ time. We can do two loops, maybe $i$ and $j$ and then see how many same elements are to the left/right ends. Wait, then looping through $j$ and $k$ will be better.

That way, we just need to find the number of $i$ and $l$ staisfying the inequality and we can do pfs/sfs on the ends. Doing pfs for each of the possible elements wouldn't be a problem because the elements are quite small.


### Implementation 
$cK$ is the possible number of $i$ for each $j$ and $k$
$cJ$ is the possible number of $l$ for each $j$ and $k$

{% highlight cpp %}
#include <bits/stdc++.h>

using ll = long long;
#define pb push_back

using namespace std;

const int MOD = 1e9+7;
const int MAXN = 2e6+1;
const int INF = 2e9;    
const long long IINF = 2e18;

#define int long long
void solve() { 
    int n;
    cin >> n;

    vector<int> v(n);
    for(int i = 0; i < n; ++i){cin >> v[i];}

    vector<vector<int>> pfs(n+1, vector<int>(n+1, 0));

    for(int i = 1; i <= n; ++i){
        pfs[i] = pfs[i-1];
        
        pfs[i][v[i-1]]++;
    }

    int ans = 0;
    for(int j = 0; j < n; ++j){
        for(int k = j+1; k < n; ++k){
            int cK = pfs[j][v[k]];
            int cJ = pfs[n][v[j]] - pfs[k+1][v[j]];
            ans += cK * cJ;
        }
    }

    cout << ans << endl;


}


int32_t main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    // freopen("test.in", "r", stdin);
    // freopen("test.out", "w", stdout);
    int t;
    cin >> t;
    while(t--){
        solve();
    }

    return 0;
}
{% endhighlight %}


See [here](https://codeforces.com/blog/entry/81916) for the solution and another implementation. 

